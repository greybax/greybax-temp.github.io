<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Javascript | Aleksandr Filatov]]></title>
  <link href="http://alfilatov.com/blog/categories/javascript/atom.xml" rel="self"/>
  <link href="http://alfilatov.com/"/>
  <updated>2015-04-13T13:11:50+00:00</updated>
  <id>http://alfilatov.com/</id>
  <author>
    <name><![CDATA[Aleksandr Filatov]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Получаем список обработчиков элемента в DOM'е]]></title>
    <link href="http://alfilatov.com/blog/2015/04/10/poluchaiem-spisok-obrabotchikov-eliemienta-stranitsy/"/>
    <updated>2015-04-10T16:55:10+00:00</updated>
    <id>http://alfilatov.com/blog/2015/04/10/poluchaiem-spisok-obrabotchikov-eliemienta-stranitsy</id>
    <content type="html"><![CDATA[<p>Допустим, что у нас есть элемент на странице. Пусть это будет <code>div</code>. Наша задача - получить все обработчики этого элемента. Рассмотрим варианты решения этой задачи в различных браузерах, а именно <code>IE</code>, <code>Firefox</code>, <code>Chrome</code>. В каждом современном браузере в консоли разработчка есть специальный UI для этих целей. Например в <code>Chrome</code> это <code>DevTools</code> -> <code>Elements</code> -> <code>Выбрать интересующий DOM узел</code> -> <code>Вкладка Event Listeners</code>. В нашем случае, поговорим о получании списка обработчиков программно.</p>

<h3>Способ 1</h3>

<ul>
<li><p>Использовать метод <code>getEventListeners(target)</code>. В браузере <code>Chrome</code> (является методом DevTools API) этот метод работает без лишних телодвижений - возвращает объект-массив эвентов на целевом элементе.</p></li>
<li><p>Ситуация с <code>Firefox</code> немного сложнее. Данный метод доступен после установки <code>Firebug</code> <a href="http://getfirebug.com/wiki/index.php/GetEventListeners">GetEventListeners</a>.</p></li>
<li><p>В <code>IE</code> все совсем плохо, т.к такой метод не реализован в API консоли разработчика и нет extensions с его аналогами (я таких не нашел).</p></li>
</ul>


<h3>Способ 2</h3>

<p>Итак, мы выяснили, что метод <code>getEventListeners</code> не является кроссбраузерным и является частью Developer Console API, поэтому рассмотрим следующий <del>костыль</del> вариант решения. Для этого нам придется переопределить нативные методы <code>Element.prototype.addEventListener</code> и <code>Element.prototype.removeEventListener</code> (для старых версий <code>IE</code> нужно переопределить свои аналоги) своими кастомными реализациями которые будут отслеживать <code>event listeners</code>.</p>

<p data-height="268" data-theme-id="0" data-slug-hash="RNzGwj" data-default-tab="result" data-user="greybax" class='codepen'>See the Pen <a href='http://codepen.io/greybax/pen/RNzGwj/'>RNzGwj</a> by Alex Filatov (<a href='http://codepen.io/greybax'>@greybax</a>) on <a href='http://codepen.io'>CodePen</a>.</p>


<script async src="//assets.codepen.io/assets/embed/ei.js"></script>


<p><strong><em>Плюс</em></strong>:</p>

<ul>
<li>Это единственный способ получить все обработчики событий (в том числе, зарегистрированные сторонними библиотеками, например, <code>jQuery</code>)</li>
</ul>


<p><strong><em>Минус</em></strong>:</p>

<ul>
<li>Cкрипт, который выполняет переопределение, должен быть выполнен первым - до <code>jQuery/Prototype/</code> и др., т.к иначе <code>event listeners</code>, зарегистрированные через эти сценарии будут не отражены.</li>
</ul>


<h3>Способ 3</h3>

<p>Можно ничего не писать и использовать сторонние реализации функции, например <a href="https://github.com/alvinteh/geteventlisteners">эту</a>.</p>

<p><strong><em>Минусы</em></strong>:</p>

<ul>
<li>Плагин, в состоянии обнаружить и получить обработчики событий, зарегистрированные <strong><em>только</em></strong> через <code>jQuery</code>.</li>
<li>Завязан на <code>jQuery</code> версии >=1.8.</li>
</ul>


<h3>Итог</h3>

<p>Универсального (кроссбраузерного) и по-настоящему хорошего варианта, к сожалению, сейчас не существует.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Что можно почитать по Frontend'у]]></title>
    <link href="http://alfilatov.com/blog/2015/03/30/gdie-ia-bieru-informatsiiu-o-mirie-frontend/"/>
    <updated>2015-03-30T10:43:02+00:00</updated>
    <id>http://alfilatov.com/blog/2015/03/30/gdie-ia-bieru-informatsiiu-o-mirie-frontend</id>
    <content type="html"><![CDATA[<p>Решил написать пост для себя, обобщив (может кому тоже будет интересно), что и где можно почитать о фронтенд разработке. В наше время успешный разработчик должен постоянно развиваться, чтобы успевать за бурным развитием технологий, часть из котороых умирает, не успев завоевать популярность, а другие становится must have.
Хочу выделить основные источники, из которых я черпаю информацию на данный момент.</p>

<h3>Статьи</h3>

<ul>
<li><a href="http://habrahabr.ru/hubs/frontend/">Хабрахабр</a></li>
<li><a href="http://frontender.info/">Frontender Magazine</a> - переводы статей иностранных авторов.</li>
</ul>


<h3>Twitter</h3>

<p>Удобно получать последние новости из твиттера. Решил выделить несколько:</p>

<ul>
<li><a href="https://twitter.com/jsunderhood">@jsunderhood</a> - каждую неделю новый разработчик рассказывает о себе и своей работе. Можно задавать вопросы и участвовать в дискуссиях</li>
<li><a href="https://twitter.com/frontenderinfo">@frontenderinfo</a> - твиттер журнала Frontender Magazine</li>
<li><a href="https://twitter.com/addyosmani">@addyosmani</a> - Engineer at Google working on Chrome &amp; Polymer. Author, Creator of TodoMVC, @Yeoman.</li>
<li><a href="https://twitter.com/jlongster">@jlongster</a> - Works on Firefox Developer Tools at Mozilla.</li>
<li><a href="https://twitter.com/getify">@getify</a> - твиттер Kyle Simpson. All things JavaScript. Open Web Evangelist.</li>
<li><a href="https://twitter.com/paul_irish">@paul_irish</a> - твиттер Paul Irish (Engineer at Google)</li>
<li><a href="https://twitter.com/kangax">@kangax</a> - Javascript maniac. Fitness enthusiast. Ex-Prototype.js core, printio.ru co-founder, @fabricjs creator, HTMLMinifier, JSCritic, ES compat tables, es-discourse</li>
</ul>


<h3>Подкасты</h3>

<ul>
<li><a href="http://radiojs.ru/">RadioJS Podcast</a> - недавно прочитал о нем в одном из твитов @jsunderhood, послушал и заинтересовался.</li>
</ul>


<h3>Meetups</h3>

<p>Одно и полезных мероприятий, где можно <del>попить пивка на афтерпати</del> вживую пообщаться с коллегами на темы приближенные твоему профилю.
Сам я из Ярославля и рад тому, что в нашем городе наконец-то появился <a href="http://yarfrontend.ru/">Yaroslavl Frontend Meetup</a>, организатором которого является компания &ldquo;Тензор&rdquo;. Также считаю, что одним из крутейших митапов у нас в стране является <a href="http://www.moscowjs.ru/">MoscowJS</a>, на котором собираются ребята из топовых компаний.</p>

<h3>Конференции</h3>

<p>Конференции, которые на мой взгляд заслуживают внимания, являются платными, поэтому пишу о них в последнюю очередь:</p>

<ul>
<li><a href="http://frontendconf.ru/">frontendconf</a> - специализированная фронтенд тусовка</li>
<li><a href="http://devconf.ru/">DevConf</a> - конференция посвещена веб разработке, в целом вне зависимости от технологий.</li>
<li><a href="http://www.msdevcon.ru/">DevCon</a> - конференция, организованная компанией Microsoft, соответственно все о технологиях MS.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Debugging файлов TypeScript в браузере через эмулятор DevExtreme]]></title>
    <link href="http://alfilatov.com/blog/2014/12/02/diebaghghingh-typescript-failov-v-emuliatorie-devextreme/"/>
    <updated>2014-12-02T19:45:38+00:00</updated>
    <id>http://alfilatov.com/blog/2014/12/02/diebaghghingh-typescript-failov-v-emuliatorie-devextreme</id>
    <content type="html"><![CDATA[<p>Недавно встала задача добавить поддержку debugging'а файлов <code>*.ts</code> в браузере. В нашем случае это Google Chrome.
Постараюсь как можно подробнее описать этот процесс.</p>

<ol>
<li><p>Для начала нужно определить в какой директории находится DevExtreme сервер, который запускает приложение, когда мы нажимаем в VS кнопку <code>Запустить в браузере Google Chrome</code>. Ответ на этот вопрос был найден в одном из тикетов на сайте <a href="https://www.devexpress.com/Support/Center/Question/Details/Q523956">DevExpress</a>. В случае Visual Studio 2012 это путь <code>C:\Program Files (x86)\Microsoft Visual Studio 12.0\Common7\IDE\Extensions\DevExtreme\WebServer</code></p></li>
<li><p>Добавляем в проект <code>*.map файл</code>. Это необходимо для связи файлов <code>js</code> и <code>ts</code></p></li>
<li><p>Заключительный этап - добавление &ldquo;символической ссылки&rdquo; на проект в директории веб сервера DevExtreme. Можно просто скопировать проект в директорию указаную выше. В этом случае мы лишим сервер возможности автоматически подхватывать изменения в проекте. Чтобы это учесть, выполним команду <a href="http://ss64.com/nt/mklink.html">mklink</a>. Для этого:</p>

<ul>
<li>Запускаем <code>cmd</code> под администратором</li>
<li>Переходим в каталог DevExpress WebServer</li>
<li>Выполняем команду <code>mklink /D &lt;project_link_name&gt; &lt;project_path&gt;</code>. В моем случае это <code>mklink /D Pos C:\Projects\Pos</code></li>
<li>Символическая ссылка <code>project_link_name</code> создана в директории <code>project_path</code></li>
</ul>
</li>
</ol>


<p>Дополнительный ссылки:</p>

<ul>
<li><a href="http://js.devexpress.com/Documentation/Howto/SPA_Framework/Application_Design/?version=14_1#Running">Running, Debugging and Deploy DevExtreme applications</a></li>
<li><a href="http://stackoverflow.com/questions/12683820/typescript-in-vs2012-automatically-generating-js-from-ts">Typescript in VS2012: (automatically) generating .js from .ts</a></li>
<li><a href="http://ss64.com/nt/">An A-Z Index of the Windows CMD command line</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Пишем игру на HTML5/JS]]></title>
    <link href="http://alfilatov.com/blog/2014/10/13/pishiem-ighru-na-html5-slash-js/"/>
    <updated>2014-10-13T08:34:07+00:00</updated>
    <id>http://alfilatov.com/blog/2014/10/13/pishiem-ighru-na-html5-slash-js</id>
    <content type="html"><![CDATA[<p>На выходных нашлось немного свободного времени и я решил попрактиковаться в <code>gamedev</code> разработке. Давно собирался написать какую-нибудь игрушку, но все руки не доходили. Бегло пробежался по сети в поисках как это делают настоящие гуру. Мне понравилась вот эта <a href="http://jlongster.com/Making-Sprite-based-Games-with-Canvas">статья</a>. За основу своей будущей игры я взял <a href="https://github.com/jlongster/canvas-game-bootstrap">фреймворк автора статьи</a>.</p>

<p><img src="/images/screenshots/towers_game2d.png" alt="Towers game 2D" /></p>

<h2>Начало</h2>

<p>Фреймворк, который я стал использовать включает в себя 4 <code>js</code> файла</p>

<ul>
<li><code>sprite.js</code> - библиотечка работы со спрайтами</li>
<li><code>resources.js</code> - подгрузка ресурсов</li>
<li><code>input.js</code> - библиотека ввода с клавиатуры</li>
<li><code>app.js</code> - основной файл игры</li>
</ul>


<p>Далее буду рассказывать только о файле <code>app.js</code>. Разберем его содержимое.</p>

<p>Для плавности анимации будем использовать <code>requestAnimationFrame</code>. Подробно о нем ознакомиться можно <a href="https://hacks.mozilla.org/2011/08/animating-with-javascript-from-setinterval-to-requestanimationframe/">здесь</a>
<code>javascript
var requestAnimFrame = (function(){
    return window.requestAnimationFrame    ||
        window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame    ||
        window.oRequestAnimationFrame      ||
        window.msRequestAnimationFrame     ||
        function(callback){
            window.setTimeout(callback, 1000 / 60);
        };
})();
</code></p>

<p>Разделим разработку нашей игры на несколько этапов:</p>

<ol>
<li>Создание и инициализация холста (canvas) на странице</li>
<li>Добавление основной функции-цикла игры</li>
<li>Инициализация и рендер объектов и ресурсов игры</li>
<li>Обработка событий ввода пользователя</li>
<li>Математика и расчет столкновений объектов в игре</li>
<li>Окончание и перезагрузка игры</li>
</ol>


<h2>Этап 1. Создание и инициализация холста</h2>

<p>Первым делом что мы должны сделать - это создать <code>canvas</code> элемент и добавить его к тегу <code>body</code> основной страницы игры.
<code>javascript
var canvas = document.createElement("canvas");
var ctx = canvas.getContext("2d");
canvas.width = 1024;
canvas.height = 520;
document.body.appendChild(canvas);
</code></p>

<ul>
<li>Создаем объект <code>canvas</code></li>
<li>Указываем, что мы создаем 2D игру (далее будем использовать везде в коде объект <code>ctx</code>)</li>
<li>Задаем размеры холста</li>
<li>Добавляем холст к тегу <code>body</code> на странице</li>
</ul>


<h2>Этап 2. Добавление основной функции-цикла</h2>

<p>Основной цикл необходим для обновления и рендера игры.
```javascript
var lastTime;
function main() {
    var now = Date.now();
    var dt = (now - lastTime) / 1000.0;</p>

<pre><code>update(dt);
render();

lastTime = now;
requestAnimFrame(main);
</code></pre>

<p>}
```
Здесь вызываем функцию requestAnimFrame (к сожалению, <a href="http://caniuse.com/#feat=requestanimationframe">поддерживается</a> не во всех браузерах), которая генерирует 60 фреймов/секунду (как это было описано выше).</p>

<h2>Этап 3. Инициализация и рендер объектов и ресурсов игры</h2>

<p>Используем <code>resource.js</code> для загрузки ресурсов в игру. Хорошим правилом является добавить все изображения  в  1 спрайт, но т.к я рисовал не сам, а брал готовые картинки, поэтому я решил с этим на заморачиваться, тем более, что в данном случае это не столь критично. Так это выглядит <a href="https://github.com/greybax/towers_game2d/blob/gh-pages/js/app.js#L57">в коде</a>
<code>javascript
resources.load([
  'img/tower.png',
    'img/sprites.png',
    'img/spider.png',
  'img/hero.png',
    'img/bullet.png',
  'img/terrain.png'
]);
resources.onReady(init);
</code>
В функции <code>init</code> загружаем мир и добавлеем хэндлер кнопки <code>reset</code>, после game over.
```javascript
function init() {
    terrainPattern = ctx.createPattern(resources.get(&lsquo;img/terrain.png&rsquo;), &lsquo;repeat&rsquo;);</p>

<pre><code>  document.getElementById('play-again').addEventListener('click', function() {
    reset();
});

reset();
lastTime = Date.now();
main();
</code></pre>

<p>}
```</p>

<h3>Начальное состояние</h3>

<pre><code class="javascript">var player = {
    pos: [0, 0],
    sprite: new Sprite('img/hero.png', [0, 0], [48, 30], 5, [0, 1, 2, 1]),
      down: new Sprite('img/hero.png', [0, 0], [48, 30], 5, [0, 1, 2, 1]),
      up: new Sprite('img/hero.png', [0, 144], [48, 30], 5, [0, 1, 2, 1]),
      left: new Sprite('img/hero.png', [0, 48], [48, 30], 5, [0, 1, 2, 1]),
      right: new Sprite('img/hero.png', [0, 96], [48, 30], 5, [0, 1, 2, 1])
};

var towers = [];
var bullets = [];
var enemies = [];
var explosions = [];

var lastTower = 0;
var gameTime = 0;
var isGameOver;
var terrainPattern;

var score = 0;
var scoreEl = document.getElementById('score');
</code></pre>

<h3>Обновление состояния игрового процесса</h3>

<p>По нашей задумке пауки должны вылезать со всех 4 сторон игрового поля. Для того чтобы это происходило случайным образом, используем функцию <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random">getRandomInt</a>.
<code>javascript
switch (getRandomInt(0,4)) {
          case 0:   //left
            enemies.push({
                pos: [0, Math.random() * (canvas.height - 30)],
                sprite: new Sprite('img/spider.png', [0, 0], [40, 30], 5, [0, 1, 2, 1])
            });
            break;
          case 1:   //top
            enemies.push({
                pos: [Math.random() * canvas.width, 0],
                sprite: new Sprite('img/spider.png', [0, 0], [40, 30], 5, [0, 1, 2, 1])
            });
            break;
            case 2: //bottom
            enemies.push({
                pos: [Math.random() * canvas.width, canvas.height - 30],
                sprite: new Sprite('img/spider.png', [0, 0], [40, 30], 5, [0, 1, 2, 1])
            });
            break;
            default: //right
            enemies.push({
                pos: [canvas.width, Math.random() * (canvas.height - 30)],
                sprite: new Sprite('img/spider.png', [0, 0], [40, 30], 5, [0, 1, 2, 1])
            });
            break;
        }
</code>
Здесь же используем <code>sprite.js</code>. Всю функцию можно посмотреть в <a href="https://github.com/greybax/towers_game2d/blob/gh-pages/js/app.js#L96">исходниках</a>.</p>

<h2>Этап 4. Обработка событий ввода пользователя</h2>

<p>Наш герой должен уметь двигаться вверх, вниз, влево, вправо. Соответственно привожу ниже реализацию данного решения
```javascript
    if (input.isDown(&lsquo;DOWN&rsquo;) || input.isDown(&rsquo;s')) {
        player.pos[1] += playerSpeed * dt;
            player.sprite = player.down;
    }</p>

<pre><code>if (input.isDown('UP') || input.isDown('w')) {
    player.pos[1] -= playerSpeed * dt;
        player.sprite = player.up;
  }

if (input.isDown('LEFT') || input.isDown('a')) {
    player.pos[0] -= playerSpeed * dt;
        player.sprite = player.left;
}

if (input.isDown('RIGHT') || input.isDown('d')) {
    player.pos[0] += playerSpeed * dt;
        player.sprite = player.right;
}
</code></pre>

<pre><code>При клике на пробел по задумке должны ставиться башни которые будут стрелять случайным образом во все стороны. Чтобы немного усложнить процесс игры башни разрешается ставить на некоторм расстоянии друг от друга. В данном случае это ```50px```.
</code></pre>

<pre><code>if (input.isDown('SPACE') &amp;&amp; !isGameOver) {
    var isClosest = false;
    for (var i = 0; i &lt; towers.length; i++) {
        if (Math.abs(player.pos[0] - towers[i].pos[0]) &lt; 50 &amp;&amp; 
            Math.abs(player.pos[1] - towers[i].pos[1]) &lt; 50) {
            isClosest = true;
        }
    }

    if (!isClosest) {
          towers[lastTower % 3] = {
            pos: [player.pos[0], player.pos[1]],
            lastFire: Date.now(),
            sprite: new Sprite('img/tower.png', [0, 0], [38, 35], 8, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15])
          };
          lastTower++;
      }
}
</code></pre>

<pre><code>
## Этап 5. Математика и расчет столкновений объектов в игре
Анимация персонажей, математика движения пуль, и логика движения NPC в игре описаны в функции ```updateEntities```. Вот тут как раз нам и потребуются базовые знания линейной алгебры.
</code></pre>

<p>  // Update the towers sprite animation
    for(var i = 0; i &lt; towers.length; i++) {
      var tower = towers[i];
      tower.sprite.update(dt);</p>

<pre><code>  if (!isGameOver &amp;&amp; Date.now() - tower.lastFire &gt; 500) {
    var pi = Math.PI;
    var x = tower.pos[0] + tower.sprite.size[0] / 2;
    var y = tower.pos[1] + tower.sprite.size[1] / 2;

    bullets.push({
      pos: [x, y],
      k: getRandomArbitrary(-5 * pi, 5 * pi),
      sprite: new Sprite('img/bullet.png', [0, 0], [24, 24]) 
    });
    tower.lastFire = Date.now();
  }
}
</code></pre>

<pre><code>Логика обновления анимации спрайтов башни. И создаем патроны для каждой башни в своем массиве. 

Динамика пуль башни:
</code></pre>

<pre><code>// Update all the bullets
for (var i = 0; i &lt; bullets.length; i++) {
    var bullet = bullets[i];

        var c = dt * bulletSpeed;
    var sin = Math.sin(bullet.k);       
    var cos = Math.cos(bullet.k);

    bullet.pos[0] += sin * c;
    bullet.pos[1] += cos * c;       

    // Remove the bullet if it goes offscreen
    if (bullet.pos[1] &lt; 0 || bullet.pos[1] &gt; canvas.height ||
        bullet.pos[0] &gt; canvas.width) {
        bullets.splice(i, 1);
        i--;
    }
}
</code></pre>

<pre><code class="">Напомню, что нашей целью было чтобы башни стреляли случайным образом во всех направлениях.

Пауков мы наделили простым интелектом и поэтому они ползут всегда за нами, чтобы нас укусить.
</code></pre>

<pre><code>// Update all the enemies
for (var i = 0; i &lt; enemies.length; i++) {
    var x0 = enemies[i].pos[0];
  var y0 = enemies[i].pos[1];
  var x1 = player.pos[0];
  var y1 = player.pos[1];
  var c = enemySpeed * dt;
  var l = Math.sqrt((x1 - x0) * (x1 - x0) + (y1 - y0) * (y1 - y0));

  enemies[i].pos[0] += (x1 - x0) * c / l;
  enemies[i].pos[1] += (y1 - y0) * c / l;

  enemies[i].sprite.update(dt);

      // Remove if offscreen
      if (enemies[i].pos[0] + enemies[i].sprite.size[0] &lt; 0) {
          enemies.splice(i, 1);
          i--;
      }
}
</code></pre>

<pre><code>
Полный код функции ```updateEntities``` можно посмотреть в [исходникак на GitHub](https://github.com/greybax/towers_game2d/blob/gh-pages/js/app.js#L179).

Математика расчета столкновений хорошо [описана](http://jlongster.com/Making-Sprite-based-Games-with-Canvas) в статье автора (раздел Collision Detection) используемого мной 2d бутстрапа.

## Этап 6. Game Over и рестарт
Когда пауки доползают до нашего героя наступает конец ~~света~~ игры. 
</code></pre>

<p>function gameOver() {
      document.getElementById(&lsquo;game-over&rsquo;).style.display = &lsquo;block&rsquo;;
    document.getElementById(&lsquo;game-over-overlay&rsquo;).style.display = &lsquo;block&rsquo;;
    isGameOver = true;
}
<code>
Показываем окно GAME OVER и кнопку "Начать заного". Кликаем ее и все начинается сначала :)
</code>javascript
function reset() {
      document.getElementById(&lsquo;game-over&rsquo;).style.display = &lsquo;none&rsquo;;
    document.getElementById(&lsquo;game-over-overlay&rsquo;).style.display = &lsquo;none&rsquo;;
    isGameOver = false;
    gameTime = 0;
      lastTower = 0;
    score = 0;</p>

<pre><code>  towers = [];
enemies = [];
bullets = [];

player.pos = [canvas.width / 2, canvas.height / 2];
</code></pre>

<p>}
```</p>

<h2>Заключение</h2>

<p>В итоге, я для себя понял, что в <code>gamedev</code> много плюсов:</p>

<ul>
<li>Весело и интересно проводишь время</li>
<li>Повторяешь курс школьной геометрии. Если игра серьезней, то и универ вспоминаешь :)</li>
<li>Практика программирования игр</li>
<li>Удовлетворение от проделанной работы</li>
</ul>


<p>Посмотреть исходники можно <a href="https://github.com/greybax/towers_game2d/">тут</a>, поиграть <a href="http://greybax.github.io/towers_game2d">здесь</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Профилирование в JS]]></title>
    <link href="http://alfilatov.com/blog/2014/09/04/profilirovaniie-v-js/"/>
    <updated>2014-09-04T13:20:43+00:00</updated>
    <id>http://alfilatov.com/blog/2014/09/04/profilirovaniie-v-js</id>
    <content type="html"><![CDATA[<p>Профилирование - это в первую очерель сбор и анализ информации, а уже потом программирование и работы по улучшению производительности программы.</p>

<h2>Зачем нужна оптимизация?</h2>

<ol>
<li>Загрузка страницы экономит нервы пользователя. Следствие из этого мы получаем лояльных пользователей.</li>
<li>Полезно разработчику, чтобы лучше понять &ldquo;узкие места&rdquo; своего сайта в которых его приложение подвисает.</li>
</ol>


<p>Самый простой способ посмотреть время загрузки <code>DOM</code> не заморачиваясь на профилировании это конечно стандартные профайлеры такие как <code>Chrome Inspector Network</code>, <code>Firebug Net Panel</code> и т.д. Итак, разберемся какие бывают способы оптимизировать работу своего приложения.</p>

<ul>
<li>Метод пристального взгляда</li>
<li>Инструментальное (средствами исполняемой среды)</li>
<li>Ручное (средствами языка)</li>
</ul>


<p>Если с первым методом все понятно, то про другие два я хочу рассказать.</p>

<h2>Инструментальное профилирование</h2>

<p>Во все актуальные версии браузеров уже встроены инструменты разработчика, в которые входит <code>profiler</code>. Так профайлеры есть в: <code>Firefox</code>, <code>IE</code>, <code>Chrome</code>.</p>

<h3>Chrome Inspector Network</h3>

<p>Версия <code>Chrome</code>: 37.0.2062.103 m
<img src="/images/screenshots/ChromeProfiler.png" alt="Chrome Profiler" /></p>

<p>Результат работы профайлера приведен выше. Есть таблица с общим и собственным временем выполнения загрузки скрипта</p>

<p>Плюсы:</p>

<ul>
<li>Возможность профилировать как производительность так и утечки памяти</li>
<li>Варинт просмотра выполнения скриптов на странице графиком и деревом вызовов</li>
<li>Доступен фокус просмотра на конрктной функции или дереве вызова функций</li>
<li>Возможность перейти в участок кода функции</li>
<li>Дерево вызовов</li>
<li>Сортировка</li>
</ul>


<p>Минусы:</p>

<ul>
<li>Слишком нагроможденный интерфейс в режиме просмотра Chart (В <code>Firefox</code> профайлере c этим дела обстоят лучше)</li>
<li>Профилирует не саму страницу, а все что видит, т.е. в профайлер попадают куча плагинов и расширений</li>
<li>Нет возможности выбрать конретный метод или конструктор который мы хотим профилировать</li>
</ul>


<p>Подробно о <a href="https://developer.chrome.com/devtools/docs/cpu-profiling">Profiling JavaScript Performance</a> и о <a href="https://developer.chrome.com/devtools/docs/javascript-memory-profiling">Javascript Memory Profiling</a></p>

<h3>Firebug Net Panel</h3>

<p>Версия <code>Firefox</code>: 32.0
<img src="/images/screenshots/FirefoxProfiler.png" alt="Firebug Profiler" /></p>

<p>Результат работы профайлера приведен выше. Здесь в интерфейс профайлера уже интегрирована диаграмма времени загрузки скриптов по умолчанию. Остальные элементы интерфейса аналогичны профайлеру в Хроме.</p>

<p>Плюсы:</p>

<ul>
<li>Диаграмма времени вызова функций и удобная фильтрация по ней</li>
<li>Возможность перейти в участок кода функции</li>
<li>Дерево вызовов</li>
<li>Сортировка</li>
<li>Удобно выделять детально промежутки времени и детально наблюдать время загрузки</li>
</ul>


<p>Минусы:</p>

<ul>
<li>Нет фильтрации по конретным функциям</li>
<li>Нет возможности выбрать конретный метод или конструктор который мы хотим профилировать</li>
</ul>


<p>Подробно о <a href="https://developer.mozilla.org/en-US/docs/Tools/Profiler">профайлере</a></p>

<h3>Internet Explorer 11</h3>

<p><img src="/images/screenshots/IEProfiler.png" alt="IE Profiler" />
Здесь аналогично Хрому есть профайлер CPU и профайлер памяти.</p>

<p>Плюсы и минусы профилировщика аналогичны тем что описаны выше. Наконец-то появилась возможность переходить прямо из профайлера в код скрипта. До <code>IE 9</code> эта функция отстутствовала.</p>

<h2>Ручное профилирование</h2>

<p>Бывают задачи когда нужно посмореть время выполнения конкретных функций или конструкторов, использовать встроенные профилировщики и разбираться в дереве вызовов в поисках нужной функции бывает довольно неудобно. На эти случаи удобно использовать следующие конструкции языка <code>javascript</code>:
<code>javascript
t = +new Date();
code_to_measure();
time = +new Date() - t;
</code>
Более удобный варинт реализует паттерн Декоратор:
<code>javascript
function profile(func) {
  var wrapper = function() {
    var start = +new Date();
    var result = func.apply(null, arguments);
    console.log(func.name, +new Date() - start, "ms");
    return result;
  }
  return wrapper;
}
</code>
Вызываем функцию профайлер так
```javascript
code_to_measure = profile(code_to_measure);
code_to_measure();</p>

<blockquote><p>code_to_measure 10 ms
```</p></blockquote>

<h2>Итог</h2>

<p>Идеального для себя профайлера я не нашел, довольно симпатичными выглядят встроенные в <code>Chrome</code> и в <code>Firefox</code>, но они не имеют части функционала которая выделяла бы их из общей массы. Тем более, оптимузируя свое приложение под тот или иной браузер приходится сталкиваться с его встроенным профайлером. Не стоит забывать и про старые ручные методы которые часто помогают.</p>
]]></content>
  </entry>
  
</feed>
